local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

-- 【新增】脚本唯一身份标识，确保重新加载时旧线程会自杀
local scriptId = "NekoMob_" .. tick()
_G.CurrentMobID = scriptId

local Net = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Net")
local RegAttack, RegHit = Net:WaitForChild("RE/RegisterAttack"), Net:WaitForChild("RE/RegisterHit")

local function getRoot(c) return c and (c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("Torso")) end
local function alive(c) local h = c and c:FindFirstChildOfClass("Humanoid") return h and h.Health > 0 end

local Targets = {}

-- ==========================================
-- 【扫描层】目标扫描逻辑
-- ==========================================
task.spawn(function()
    local p = OverlapParams.new()
    -- 只有当 ID 匹配时才运行
    while _G.CurrentMobID == scriptId do
        if _G.MOB or _G.PVP then
            local mr = getRoot(player.Character)
            if mr then
                local pl, ml = {}, {}
                -- 扫描 2500 范围内的零件
                local parts = workspace:GetPartBoundsInRadius(mr.Position, 2500, p)
                for _, v in ipairs(parts) do
                    local m = v.Parent
                    if m and alive(m) and m ~= player.Character then
                        local isP = Players:GetPlayerFromCharacter(m)
                        -- 根据开关分类目标
                        if isP and _G.PVP then table.insert(pl, m)
                        elseif not isP and _G.MOB then table.insert(ml, m) end
                    end
                end
                
                -- 排序逻辑保持不变
                local sfn = function(a, b) 
                    local ra, rb = getRoot(a), getRoot(b)
                    if ra and rb then
                        return (ra.Position - mr.Position).Magnitude < (rb.Position - mr.Position).Magnitude 
                    end
                    return false
                end
                table.sort(pl, sfn)
                table.sort(ml, sfn)
                
                local f = {}
                for _, o in ipairs(pl) do if #f < 50 then table.insert(f, o) end end
                for _, o in ipairs(ml) do if #f < 50 then table.insert(f, o) end end
                Targets = f
            end
        else
            Targets = {}
        end
        task.wait(0.3)
    end
end)

-- ==========================================
-- 【执行层】自动攻击逻辑
-- ==========================================
task.spawn(function()
    -- 只有当 ID 匹配时才运行
    while _G.CurrentMobID == scriptId do
        -- 判断 UI 开关及是否有目标
        if (_G.MOB or _G.PVP) and #Targets > 0 then
            local char = player.Character
            local root = getRoot(char)
            local tool = char and char:FindFirstChildOfClass("Tool")
            
            if tool and root then
                local firstTarget = Targets[1]
                local r = getRoot(firstTarget)
                
                local nl = {}
                for i = 1, #Targets do
                    local tr = getRoot(Targets[i])
                    if tr then table.insert(nl, {Targets[i], tr}) end
                end
                
                if #nl > 0 and r then
                    -- 瞬移攻击逻辑
                    local oldCF = root.CFrame
                    root.CFrame = r.CFrame * CFrame.new(0, 0, 1.2)
                    
                    -- 执行攻击包
                    for _ = 1, 3 do 
                        RegAttack:FireServer(0)
                        RegHit:FireServer(r, nl)
                    end
                    
                    root.CFrame = oldCF
                end
            end
        end
        -- 使用 Stepped 确保频率同步
        RunService.Stepped:Wait()
        
        -- 如果开关被关闭，在此处稍作等待，防止空转占用 CPU
        if not (_G.MOB or _G.PVP) then
            task.wait(0.5)
        end
    end
    print("旧的刷怪攻击脚本已退出。")
end)
